 <span id="mulu"></span>

# 场景              

[1. 入门](#1)  
 
[2. 使用场景加载管理器前往另一个场景](#2)  
 
[3. 通过LevelManager加载场景](#3) 
 
[4. 关卡选择](#4) 

[5. 场景里的房间](#5) 

[6. 移动到另一个场景的某一点](#6) 

[7. 程序生成关卡](#7) 

<p id="1"></p>              

## 1. 入门
 
你的游戏很可能是由多个关卡或部分组成的。在TopDown Engine中，就像在Unity中一样，你可以使用多种方法来构建关卡。最直接的方法是在每个关卡创造一个场景，并在关卡末尾设置一个门/门/终点线，从而引导玩家进入下一个关卡，但你也可以在一个场景中创造多个部分。除此之外，引擎还提供了链接关卡、保存数据、创建关卡选择屏幕和角色选择屏幕的方法。这一页涵盖了所有这些
 
[返回目录](#mulu)

<p id="2"></p>              

## 2. 使用场景加载管理器前往另一个场景
 
使用Unity，通常当你想进入另一个场景(在菜单中，或从一个级别到下一个级别)，你会使用SceneManager API，可能还有SceneManager. loadscene()方法。原生方法不能提供给玩家足够的视觉反馈，例如手机上的场景加载可能需要几秒钟的时间，所以只有黑屏并不好看。为了解决这个问题，引擎自带了自己的场景改变API，如果你不喜欢它，你完全可以不使用它。

 ![示例图片](/images/scenes-1.png)

如果你想为玩家提供更好的体验，你可以使用MMSceneLoadingManager:

    它可以从任何地方调用，你不需要在场景中有MMSceneLoadingManager

    它处理加载(顾名思义)，显示动画和进度条

    它是完全可定制的，只需编辑ThirdParty/MoreMountains/MMTools/Tools/MMSceneLoading/LoadingScreens/LoadingScreen场景的内容。你可以很容易地添加你自己的标志，改变进度条的外观，播放什么动画，等等。

    它使用起来很简单

要使用MMSceneLoadingManager API，当你想要改变级别时，只需调用MMSceneLoadingManager。LoadScene(字符串sceneToLoad)方法。您传递的字符串参数当然必须与您试图加载的场景的名称匹配。所以如果你要加载Koala地下城关卡，你可以使用:

 ```
 MMSceneLoadingManager.LoadScene ("KoalaDungeon");
 ```
剩下的就交给引擎了

[返回目录](#mulu)

<p id="3"></p>              

## 3. 通过LevelManager加载场景
 
在LevelManager的检查器中，你可以定义LoadingSceneMode。然后引擎中的一些类会使用这个方法，如FinishLevel脚本或LevelSelector，从一个场景切换到另一个场景。三种模式:

    UnityNative:将简单地使用SceneManager API来加载一个新场景

    MMSceneLoadingManager，将使用MMSceneLoading API加载一个新场景，如上所述。在这种模式下，你必须指定使用哪个场景作为加载场景。你可以开箱即用地设置“LoadingScreen”来使用相同名称的场景。请确保将其添加到构建设置中。

    MMAdditiveSceneLoadingManager，将使用更高级的添加场景加载系统。你还必须指定一个加载场景的名称，你可以选择任何位于ThirdParty/MoreMountains/MMTools/Tools/MMSceneLoading/LoadingScreens/LoadingScreen的附加的名称。如果您不知道选择哪一个，请从MMAdditiveLoadingScreen开始。这种模式提供了许多选项，可以让您完全控制每一步的时间，包括渐变、线程优先级、延迟等。
 
### 创建一个新的加载屏幕

    在Unity 2019.4.28f1上重新安装TopDown Engine v2.1

    复制LoadingScreen演示场景，命名为NewLoadingScreen

    添加到你的构建设置(文件，构建设置，拖动你的NewLoadingScreen到“Scenes in build”面板)

    打开它，选择主摄像机，在它的摄像机组件上，让我们将背景颜色改为红色(如果你想，你可以在场景中做其他更改，但红色是我们确保使用正确的颜色的方式)

    保存场景

    打开Minimal2DDoors1，在它的LevelManager中，设置LoadingSceneName为NewLoadingScreen

    按下播放键，向上/右移穿过绿色的门，然后向右移动直到你看到蓝色的门，进入它(按下空格)，注意到我们正在使用新创建的加载屏幕加载我们的新场景

[返回目录](#mulu)

<p id="4"></p>  

## 4. 关卡选择
 
这个引擎内置了关卡选择的例子。它是一个旋转木马，包含显示每个关卡信息的卡片，即LevelSelection场景。就逻辑而言，这是相当简单的，只需使用LoadingSceneManager进入选定的关卡
 
[返回目录](#mulu)

<p id="5"></p>  

## 5. 场景里的房间
 
在某些情况下，在一个更大的场景中创建不同的部分可能是一个好主意。在这种情况下，您将希望使用传送器组件。你可以在许多演示关卡中看到它的作用，并在Minimal2DDoors1演示场景中关注它。它的使用非常简单，你只需要在你的场景中使用两个(或更多)，你通过它们的检查器链接它们，定义它们的行为，然后你就可以开始了。
 
[返回目录](#mulu)

<p id="6"></p>  

## 6. 移动到另一个场景的某一点
 
该引擎还允许你将不同的场景连接在一起，并根据你来自哪里，指定每个场景的开始位置。也许你走到场景A的顶部，那里有一扇门把你送到场景b，但也可能在场景A的底部有一扇门把你送到场景c。一旦你到了场景b，你想回到场景A的顶部，等等。这正是Minimal2DDoors1和Minimal2DDoors2演示场景所展示的。它们使用GoToLevelEntryPoint组件。

它很容易使用，但需要一些设置。首先，你需要在目标关卡中创建入口点(如果你在场景A，并想要进入场景B，你的目标关卡便是场景B)。要在场景B中创建入口点，你只需要创建并定位空对象，或者选择现有的对象(如检查点)。然后选择场景B的LevelManager，在它的检查器中定义你希望这个场景有多少个入口点，并一个一个地将它们绑定在那里。

完成之后，回到场景A，创建一个带有GoToLevelEntryPoint脚本的门/对象。设置它的各种激活条件和设置，设置相应的级别名称(在我们的例子中是场景B)，并设置该对象的入口索引点。记住，索引从0开始。所以如果你在SceneB的LevelManager中有3个入口点，索引0是列表中的第一个点，索引1是第二个点，以此类推。就这样，你可以开始了
 
[返回目录](#mulu)

<p id="7"></p>  

## 7. 程序生成关卡
虽然引擎中的大多数演示都是手工制作关卡，当场景开始时就已经在编辑器中确定了，但没有什么能阻止你按程序生成关卡。只有两件事你需要注意:

    确保你在on Awake下生成的关卡，这样它们就可以在开始状态下使用。

    确保你的关卡符合引擎的规格，生成的结果与你手动操作的结果相匹配(游戏邦注:墙壁位于障碍层，你的角色可以行走在地面上，关卡管理器的边界大小调整正确等等)。
 
你会在KoalaProceduralTilemap演示场景中找到一个例子。这个场景使用了MMTilemapGenerator的扩展版本，即TilemapLevelGenerator。TilemapLevelGenerator是为TopDown引擎定制的，它不仅会基于你所定义的规则生成一个新的tilemap，还会自动生成墙壁阴影，将入口和出口放置在合理和可到达的位置，并将调整关卡管理器的大小。如果它符合您的需求，您可以直接使用它，或者您可以参考它来实现自己的程序生成系统。

 ![示例图片](/images/scenes-2.png)

TilemapGenerator通过生成0和1的网格来工作，并使用这些绘制一个Unity Tilemap(0保持空，1成为一个完整的tile)。它使用许多不同的算法来生成这些0和1的数组，并允许您组合和定制它们以获得非常独特的结果。

以下是它的检查器，它可以让你生成各种关卡:

    Grid:让你定义网格的大小。您可以为其宽度和高度设置最小值和最大值。这将在这些最小和最大界限之间生成一个随机大小，在某些情况下你不希望关卡总是相同的大小。当然，如果你为宽度的最小值和最大值设置相同的值，它将保持不变。

    Global Seed:这个生成器是种子的，这意味着如果你使用相同的种子，你总是会得到相同的结果。如果你想让角色回到之前生成的关卡，这将非常有用。你所需要做的便是储存这些种子并使用它们重新创造一个关卡。复选框还允许您自动生成新的种子，但是如果您愿意，您可以自己处理生成。

    Slow Render:这只是为了展示，只会在运行时工作。它允许你逐个贴图渲染关卡的生成。看起来不错。如果您在测试目的之外这样做，那么就不太实用(并且可能会导致问题)。

    TopDown引擎设置:一个复选框会让你决定是否应该在Awake时自动生成。绑定可以让你定义使用什么Grid，使用什么tilemap作为障碍物，在哪个tilemap上绘制墙壁阴影，最后一个槽可以让你绑定LevelManager。然后你可以绑定你的InitialSpawn和Exit，以及你想保持它们之间的距离。在生成时，系统将生成一个新关卡，然后将这两个关卡放置在可到达的位置。

    Layers:这就是神奇发生的地方。每一层都有一个要绘制的目标磁贴图，以及定义如何绘制磁贴的设置。这些设置的细分如下:

    Layers:Name:纯粹用于您自己的组织目的，通常指定该层将绘制什么

    Layers: Active:如果未勾选此选项，在生成关卡时该层将不会被处理

    Layers:Tilemaps:允许你拖动一个目标Tile来绘制，以及使用什么Tile来绘制它

    Layers:Override Grid Size:默认情况下，每一层将绘制生成器一般网格大小设置大小的网格。但你也可以在每层的基础上重写它。

    Layers: Post Processing:平滑选项将在生成的网格上应用平滑，衰减所有孤立的点和峰值。反向网格将把所有的0变成1，反之亦然。如果你对一个形状很满意，但想“如果它是相反的”，这就是你的复选框。

    Layers:Fusion Mode:这些融合模式将从上到下应用在图层上(最后发言的获胜)。Normal只生成一个网格，默认模式。NormalNoClear生成一个网格，但不会首先清除它。相交:当在已经有内容的目标网格上绘制时，只会保持产生的交集。合并:将此网格的结果添加到现有目标。减去:从现有目标中移除该网格的结果。

    Layers:Generate Methods:可以用来生成模式的一系列算法。Full:填充整个网格。柏林:使用柏林噪声生成图案。PerlinGround:同样的事情，但目标是在网格底部保持一个可行走的“地面”。随机:随机绘制0和1。RandomWalk:选择一个起始位置，然后像一个特工一样在路径上留下痕迹。RandomWalkAvoider:同样的事情，但Walker会在你可以指定的一个单独的tilemap上避开障碍物。RandomWalkGround:随机绘制一条路径，但尽量保持一个可行走的地面。Path:按照指定的随机维度雕刻一条路径。Copy:拷贝目标磁贴图。

    Layers : Bounds:用1s绘制左、右、上或下边界(或这些边界的组合)。

    Layers: Safe Spots:允许您定义许多安全地点(在网格坐标中定义)，其中该层只绘制0。

 ![示例图片](/images/scenes-3.png)

    在TopDown引擎的KoalaProceduralTilemap演示场景中的层

这个系统可能需要一些时间来适应，但它非常强大，可以作为您自己的更大的解决方案的良好基础。不要犹豫，看看KoalaProceduralTilemap演示场景，在它中，你会发现一个带有5层的生成器已经设置，以生成有趣的模式:

    Grass:这一层只是在地面贴图上绘制了一个完整的草贴图网格，作为我们关卡的基础

    Walls Random Walk:使用随机漫步生成，该层用墙壁绘制50%的地图

    Walls Path:该层使用Combine融合模式为其上一层生成的墙壁网格添加额外的垂直路径

    Ground Tiles:这层装饰瓷砖在地面上随机掉落，以20%填充率为目标

    Ground Path:这一层使用RandomWalkAvoider算法在地面上画一条橙色的路径，试图避开墙壁，以提供真实的结果

最后一件事:这个系统没有限制。演示版本会生成相对较小的关卡(测试速度更快)，但只要对上面描述的图层进行一些调整，并将Grid大小乘以10，你就可以生成完整的世界:

 ![示例图片](/images/scenes-4.png)
[返回目录](#mulu)
